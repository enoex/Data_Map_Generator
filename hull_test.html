<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Convex Hull</title>
    <script type="text/javascript" src="../../d3.js"></script>
    <script type="text/javascript" src="../../d3.geom.js"></script>
    <style type="text/css">

svg {
  border: solid 1px #aaa;
  background: #eee;
}

path {
  fill: lightsteelblue;
  stroke: #000;
}

circle {
  fill: #fff;
  stroke: #000;
}

    </style>
  </head>
  <body>
    <script type="text/javascript">

var w = 960,
    h = 500;

var vertices = d3.range(15).map(function(d) {
  return [
    w / 4 + Math.random() * w / 2,
    h / 4 + Math.random() * h / 2
  ];
});

/*
vertices = [
    [20,100],
    [100,100],
    [400,100],
    [700,400],
    [100,300]
]
*/
var svg = d3.select("body")
  .append("svg:svg")
    .attr("width", w)
    .attr("height", h)
    .attr("pointer-events", "all")
    .on("mousemove", move)
    .on("click", click);

update();

function update() {
  svg.selectAll("path")
      .data([d3.geom.hull(vertices)])
      .attr("d", function(d) { return generate_points(d) })
	  .enter().append("svg:path")
	    .attr("d", function(d) { return generate_points(d) });

  svg.selectAll("circle")
      .data(vertices.slice(1))
    .enter().append("svg:circle")
      .attr("transform", function(d) { return "translate(" + d + ")"; })
      .attr("r", 3);
}

function generate_points(d){
    var jagged_borders= [];
    var jagged_step_amount = 20;
    var jaggedness_factor = 7;
    var x1=0, xj=0, x2=0, y1=0, yj=0, y2=0;

    //Loop through the continent's vertices and
    //  add them, along with intermediate points (to
    //  create the jagged effect) to the jagged_borders
    //  array
    for(k=0, d_len=d.length; k < d_len; k++){
        //Add the current vertex to the jagged_borders
        jagged_borders.push(d[k]);

        //If we're not at the final vertex, then add 
        //  some points in between this vertex and the
        //  next one
        if(k + 1 < d_len){
        //if(k===2){
            //Add some random vertices
            // We'll do this in a loop so we can add
            // an arbitrary amount of jaggedness

            //The way this works is we add a vertex
            //  in between the current point and the
            //  next one (this doesn't happen if we're 
            //  at the last index
            //The 'in between' points will be added
            //  based on some 'step' variable (
            //  as opposed to recursively getting
            //  midpoints or something).  The step
            //  variable will be either negative
            //  or positive depending if the
            //  next continent border vertex is
            //  greater or less than the current
            //  one
            jagged_cur_iteration=1;
            while(true){
                check_x_coord = false;
                check_y_coord = false;

                use_x_coord = true;
                use_y_coord = true;
                
                //By default, the jagged_vertex
                //will contain the next 
                //  point's coords
                jagged_vertex = [
                    d[k][0],
                    d[k][1]
                ];

                //Use x1, x2 and y1, y2 to keep things clearer
                x1 = d[k][0];
                //xj is x1 + local_step_amount, which is defined in
                // the checks below (xj might be negative)       
                xj = 0
                x2 = d[k+1][0];

                y1 = d[k][1];
                yj = 0
                y2 = d[k+1][1];
                
                //The current step amount is equal to
                //  the base step amount * the current
                //  iteration
                local_step_amount = (jagged_step_amount
                    * jagged_cur_iteration);

                //---------------
                //Check for use_xy_coord variables
                //---------------
                //X
                //-----------
                //Check to see if we need to make the
                //  step variable positive or negative
                if(x1 < x2){
                    //Positive amount 
                    //Get xj 
                    xj = x1 + local_step_amount;
                    
                    //Set the check_x_coord variable 
                    //  The check is done by seeing if x1 plus the 
                    //  step amount exceeds x2.  If it doesn't, we
                    //  need to check the x coord
                    if(x1 + jagged_step_amount <= x2){
                        check_x_coord = true

                        //Check if this amount exceeds
                        //  the next vertex
                        //This is ignored if check_x_coord is false
                        if(xj >= x2){
                            //Dont use the x coord
                            use_x_coord = false;
                        }
                    }
                }else{
                    //Negative amount
                    local_step_amount = (local_step_amount 
                        * -1);
                    xj = x1 + local_step_amount;

                    //Set check_x_coord
                    //  Use greater than since we're using negative coords
                    if(x1 + (jagged_step_amount * -1) >= x2){
                        check_x_coord = true;
                    }
                    //Set use_x_coord
                    if(xj <= x2){
                        //Dont use the x coord
                        use_x_coord = false;
                    }
                }

                //-----------
                //Y
                //-----------
                //reset local step count
                local_step_amount = (jagged_step_amount
                    * jagged_cur_iteration);

                if(y1 < y2){
                    //Positive amount 
                    yj = y1 + local_step_amount;

                    //Set check_y_coord
                    if(y1 + jagged_step_amount <= y2){
                        check_y_coord = true
                    }

                    //Set use_y_coord
                    if(yj >= y2){
                        use_y_coord = false;
                    }
                }else{
                    //Negative amount
                    local_step_amount = (local_step_amount 
                        * -1);
                    yj = y1 + local_step_amount;
                    
                    //Set check_x_coord
                    //  Use greater than since we're using negative coords
                    if(y1 + (jagged_step_amount * -1) >= y2){
                        check_y_coord = true;
                    }
                    if(yj <= y2){
                        //Dont use the x coord
                        use_y_coord = false;
                    }
                }

                //-----------------------
                //
                //Setup jagged vertex
                //
                //-----------------------
                //Setup X and Y Coords for jagged_vertex
                //  Determine if the base should be xj/yj
                //  or if it should stay as x1 / x2 (for 
                //  straight line segments)
                if(check_x_coord === true){
                    if(use_x_coord === true){
                        jagged_vertex[0] = xj;
                    }
                }

                if(check_y_coord === true){
                    if(use_y_coord === true){
                        jagged_vertex[1] = yj;
                    }
                }

                //-----------------------
                //Setup jagged vertex values
                //-----------------------
                jagged_vertex[0] += (
                    (jaggedness_factor * -1)
                        + (Math.random() 
                        * (jaggedness_factor * 2))
                    );


                // Y Coord
                jagged_vertex[1] += (
                    (jaggedness_factor * -1)
                        + (Math.random() 
                        * (jaggedness_factor * 2))
                    );

                /*
                console.log(
                    '----',
                    jagged_vertex,
                    'use x: ' + use_x_coord 
                        + ', check x: ' + check_x_coord,
                    ' ||||| ',
                    'use y: ' + use_y_coord
                        + ', check y: ' + check_y_coord
                );
                */
                //Increase the loop counter
                jagged_cur_iteration += 1;

                //If we CAN'T use both x and y coords,
                //  end the loop.  
                //  Otherwise, if both x
                //  and y coords are usable then
                //  use them
                //Check to see if x AND y need to be checked
                //TODO: FIX
                //if(jagged_cur_iteration > 8){
                //    break;
                //}
                if(check_x_coord === true && check_y_coord === true){
                    if(use_x_coord === false 
                        & use_y_coord === false ){
                        break;
                    }
                }else if(check_x_coord === true && check_y_coord === false){
                    //Check to see if only the x needs to be checked
                    if(use_x_coord === false){
                        break;
                    }
                }else if(check_y_coord === true && check_x_coord === false){
                    //Check to see if only the x needs to be checked
                    if(use_y_coord === false){
                        break;
                    }
                }

                //It's ok to add another point, so do it!
                jagged_borders.push(
                    [ jagged_vertex[0],
                        jagged_vertex[1]
                    ]
                );

                
            }
        }
    }

    //Set up the path for this clipping path
    return "M" + jagged_borders.join("L") + "Z"; 
}

function move() {
  vertices[0] = d3.svg.mouse(this);
  update();
}

function click() {
  vertices.push(d3.svg.mouse(this));
  update();
}
    </script>
  </body>
</html>
